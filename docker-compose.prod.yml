# ==============================================================================
# Docker Compose Production Configuration - SystÃ¨me Gaveurs V3.0
# ==============================================================================
# Optimized production setup with security, monitoring, and high availability
#
# Usage:
#   docker-compose -f docker-compose.prod.yml up -d
#   docker-compose -f docker-compose.prod.yml logs -f
#   docker-compose -f docker-compose.prod.yml ps
#   docker-compose -f docker-compose.prod.yml down
#
# Prerequisites:
#   - Create .env.production file (see .env.production.template)
#   - Run: docker-compose -f docker-compose.prod.yml build
#   - Ensure SSL certificates are in ./nginx/ssl/ directory
# ==============================================================================

services:
  # ============================================================================
  # TimescaleDB - Production Database
  # ============================================================================
  timescaledb:
    image: timescale/timescaledb:latest-pg15
    container_name: gaveurs_timescaledb_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    environment:
      POSTGRES_DB: ${DATABASE_NAME:-gaveurs_db}
      POSTGRES_USER: ${DATABASE_USER:-gaveurs_admin}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_INITDB_ARGS: "-E UTF8"
      # Performance tuning
      POSTGRES_MAX_CONNECTIONS: 200
      POSTGRES_SHARED_BUFFERS: 2GB
      POSTGRES_EFFECTIVE_CACHE_SIZE: 6GB
      POSTGRES_MAINTENANCE_WORK_MEM: 512MB
      POSTGRES_WORK_MEM: 16MB
      POSTGRES_WAL_BUFFERS: 16MB
      POSTGRES_CHECKPOINT_COMPLETION_TARGET: 0.9
    ports:
      - "127.0.0.1:5432:5432"  # Only expose to localhost
    volumes:
      - timescaledb_data:/var/lib/postgresql/data
      - timescaledb_backups:/backups
      - ./backend-api/scripts:/docker-entrypoint-initdb.d:ro
      # Custom PostgreSQL configuration
      - ./docker/timescaledb/postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./docker/timescaledb/pg_hba.conf:/etc/postgresql/pg_hba.conf:ro
    networks:
      - db_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER:-gaveurs_admin} -d ${DATABASE_NAME:-gaveurs_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
        reservations:
          cpus: '2'
          memory: 4G
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "5"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Redis - Cache & Session Management
  # ============================================================================
  redis:
    image: redis:7-alpine
    container_name: gaveurs_redis_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redis_data:/data
      - ./docker/redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
    networks:
      - backend_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: redis-server /usr/local/etc/redis/redis.conf
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Backend API - FastAPI with Gunicorn
  # ============================================================================
  backend:
    build:
      context: ./backend-api
      dockerfile: Dockerfile.prod
      args:
        BUILD_DATE: ${BUILD_DATE}
        VERSION: ${VERSION:-3.0.0}
    image: gaveurs/backend:${VERSION:-3.0.0}
    container_name: gaveurs_backend_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /app/logs
    user: "1000:1000"  # Non-root user
    environment:
      # Database
      DATABASE_HOST: timescaledb
      DATABASE_PORT: 5432
      DATABASE_NAME: ${DATABASE_NAME:-gaveurs_db}
      DATABASE_USER: ${DATABASE_USER:-gaveurs_admin}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}
      DATABASE_POOL_SIZE: 20
      DATABASE_MAX_OVERFLOW: 40

      # Redis
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379

      # Application
      APP_ENV: production
      LOG_LEVEL: ${LOG_LEVEL:-info}
      DEBUG: "false"

      # Security
      SECRET_KEY: ${SECRET_KEY}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY}
      JWT_ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: 30

      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS}

      # Gunicorn
      WORKERS: ${GUNICORN_WORKERS:-4}
      WORKER_CLASS: uvicorn.workers.UvicornWorker
      WORKER_CONNECTIONS: 1000
      TIMEOUT: 120
      KEEPALIVE: 5

      # Monitoring
      ENABLE_METRICS: "true"
      METRICS_PORT: 9100
    ports:
      - "127.0.0.1:8000:8000"  # Only expose to localhost (nginx reverse proxy)
      - "127.0.0.1:9100:9100"  # Metrics endpoint
    depends_on:
      timescaledb:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - backend_network
      - db_network
    volumes:
      - backend_logs:/app/logs
      - backend_cache:/app/cache
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 4G
        reservations:
          cpus: '2'
          memory: 2G
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "5"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Frontend Euralis - Next.js (Nginx)
  # ============================================================================
  frontend-euralis:
    build:
      context: ./euralis-frontend
      dockerfile: Dockerfile.prod
      args:
        NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
        BUILD_DATE: ${BUILD_DATE}
        VERSION: ${VERSION:-3.0.0}
    image: gaveurs/frontend-euralis:${VERSION:-3.0.0}
    container_name: gaveurs_frontend_euralis_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
      - /var/run
    user: "101:101"  # nginx user
    ports:
      - "127.0.0.1:3000:80"
    depends_on:
      - backend
    networks:
      - frontend_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Frontend Gaveurs - Next.js (Nginx)
  # ============================================================================
  frontend-gaveurs:
    build:
      context: ./gaveurs-frontend
      dockerfile: Dockerfile.prod
      args:
        NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
        BUILD_DATE: ${BUILD_DATE}
        VERSION: ${VERSION:-3.0.0}
    image: gaveurs/frontend-gaveurs:${VERSION:-3.0.0}
    container_name: gaveurs_frontend_gaveurs_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
      - /var/run
    user: "101:101"  # nginx user
    ports:
      - "127.0.0.1:3001:80"
    depends_on:
      - backend
    networks:
      - frontend_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Frontend SQAL - React + Vite (Nginx)
  # ============================================================================
  frontend-sqal:
    build:
      context: ./sqal
      dockerfile: Dockerfile.prod
      args:
        VITE_API_URL: ${VITE_API_URL}
        VITE_WS_URL: ${VITE_WS_URL}
        BUILD_DATE: ${BUILD_DATE}
        VERSION: ${VERSION:-3.0.0}
    image: gaveurs/frontend-sqal:${VERSION:-3.0.0}
    container_name: gaveurs_frontend_sqal_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
      - /var/run
    user: "101:101"  # nginx user
    ports:
      - "127.0.0.1:5173:80"
    depends_on:
      - backend
    networks:
      - frontend_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Nginx Reverse Proxy - SSL Termination & Load Balancing
  # ============================================================================
  nginx-proxy:
    image: nginx:1.25-alpine
    container_name: gaveurs_nginx_proxy_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
      - /var/run
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./docker/nginx/conf.d:/etc/nginx/conf.d:ro
      - ./docker/nginx/ssl:/etc/nginx/ssl:ro
      - nginx_logs:/var/log/nginx
      - letsencrypt_certs:/etc/letsencrypt:ro
      - letsencrypt_challenges:/var/www/certbot:ro
    depends_on:
      - backend
      - frontend-euralis
      - frontend-gaveurs
      - frontend-sqal
    networks:
      - frontend_network
      - backend_network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "5"
        tag: "{{.Name}}/{{.ID}}"

  # ============================================================================
  # Certbot - SSL Certificate Management (Let's Encrypt)
  # ============================================================================
  certbot:
    image: certbot/certbot:latest
    container_name: gaveurs_certbot
    restart: "no"
    volumes:
      - letsencrypt_certs:/etc/letsencrypt
      - letsencrypt_challenges:/var/www/certbot
      - certbot_logs:/var/log/letsencrypt
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    networks:
      - frontend_network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # ============================================================================
  # SQAL Simulator - IoT Sensor Data (Production Continuous)
  # ============================================================================
  simulator-sqal:
    build:
      context: ./simulator-sqal
      dockerfile: Dockerfile.prod
    image: gaveurs/simulator-sqal:${VERSION:-3.0.0}
    container_name: gaveurs_simulator_sqal_prod
    restart: always
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
    user: "1000:1000"
    environment:
      TZ: Europe/Paris
      BACKEND_WS_URL: ws://backend:8000/ws/sensors/
      DEVICE_ID: ${SQAL_DEVICE_ID:-ESP32_PROD_01}
      LOG_LEVEL: ${LOG_LEVEL:-info}
    command: >
      python main.py
      --device ${SQAL_DEVICE_ID:-ESP32_PROD_01}
      --location "Ligne A - Production"
      --backend-url ws://backend:8000/ws/sensors/
      --interval ${SQAL_INTERVAL:-30}
      --config-profile foiegras_standard_barquette
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - backend_network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.25'
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"
        tag: "{{.Name}}/{{.ID}}"

# ==============================================================================
# Networks - Segmented for Security
# ==============================================================================
networks:
  # Frontend network - public facing services
  frontend_network:
    driver: bridge
    name: gaveurs_frontend_prod
    ipam:
      config:
        - subnet: 172.20.0.0/24
    driver_opts:
      com.docker.network.bridge.name: br-gaveurs-frontend

  # Backend network - application services
  backend_network:
    driver: bridge
    name: gaveurs_backend_prod
    internal: false  # Allow external access for WebSocket
    ipam:
      config:
        - subnet: 172.21.0.0/24
    driver_opts:
      com.docker.network.bridge.name: br-gaveurs-backend

  # Database network - isolated database access
  db_network:
    driver: bridge
    name: gaveurs_db_prod
    internal: true  # No external access
    ipam:
      config:
        - subnet: 172.22.0.0/24
    driver_opts:
      com.docker.network.bridge.name: br-gaveurs-db

# ==============================================================================
# Volumes - Persistent Storage
# ==============================================================================
volumes:
  # Database
  timescaledb_data:
    name: gaveurs_timescaledb_data_prod
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/timescaledb

  timescaledb_backups:
    name: gaveurs_timescaledb_backups_prod
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/backups

  # Cache
  redis_data:
    name: gaveurs_redis_data_prod

  # Application
  backend_logs:
    name: gaveurs_backend_logs_prod
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/logs/backend

  backend_cache:
    name: gaveurs_backend_cache_prod

  # Nginx
  nginx_logs:
    name: gaveurs_nginx_logs_prod
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./data}/logs/nginx

  # SSL Certificates
  letsencrypt_certs:
    name: gaveurs_letsencrypt_certs_prod

  letsencrypt_challenges:
    name: gaveurs_letsencrypt_challenges_prod

  certbot_logs:
    name: gaveurs_certbot_logs_prod
